# 第三讲 树（上）

## 3.1 树与树的表示

什么是树

+ 表示事物的层次结构
  + 人类社会家谱
  + 文件管理
  + 社会组织结构

为什么要采用树：分层次组织在管理上有更高的效率

### 3.1.1 例：顺序查找

数据管理的基本操作之一：查找

如何高效进行查找？

+ 查找：根据某个给定的关键字，从集合中找出关键字相同的记录
  + 静态查找：集合中的记录固定
    + 没有插入和删除操作，只有查找
  + 动态查找：集合记录动态变化
    + 还可能发生插入和删除

+ 静态查找
  + 顺序查找
    + 哨兵（减少判断分支）
    + 时间复杂度 $T(n)=O(n)$
  + 二分查找 3.1.2  

### 3.1.2 例：二分查找

Binary Search
要求数据有序存放
并且要求存放在数组中（逻辑上连续的一段空间）

具有对数复杂度

### 3.1.3 二分查找实现

二分查找判定树

例：11个元素的二分查找判定树

判定树上每个结点需要的查找次数刚好为该节点所在的层数‘

查找树可以很好地解决动态查找问题

### 3.1.4 树的定义和术语

+ 树(Tree)：n（$n\ge0$）个结点构成的有限集合，n=0时，称为空树
  + 对于一棵非空树（$n>0$）具备以下性质
    + 树中有一个称为“树根”(Root)的特殊结点，用r表示
    + 其余结点可以划分为m个不相交的子集$T_1,T_2,\dots,T_m$。其中每个集合本身又是一棵树，称为原来树的“子树”(SubTree)
    + 树的定义采用了一种递归的方法
  + 树的特点
    + 子树不相交
    + 除了根节点外，每个结点有且仅有一个父节点
    + 一棵N个结点的树有N-1条边
  + 树的一些基本术语
    + 结点的度(Degree)：结点的子树个数
    + 树的度：树的所有结点中最大的度数
    + 叶结点(Leaf)：度为0的结点
    + 父结点(Parent)：子树根节点的父结点
    + 子结点(Child)：与父结点相对
    + 兄弟结点(Sibling)：具有同一父结点的结点
    + 路径和路径长度：结点之间的路径（要求子结点关系）。路径包含边的个数为路径的长度
    + 祖先结点(Ancestor)：沿树根到某一结点路径上的所有结点
    + 子孙结点(Descendant)：某一结点子树的所有结点
    + 结点的层次(Level)：规定根结点在第一层，任一结点的层数是其父结点的层数加1
    + 树的深度(Depth)：树中所有结点中的最大层次

### 3.1.5 树的表示

使用数组，链表实现

使用二叉树表示整个树(Child-Sibling)

二叉树：度为2的树

## 3.2 二叉树及存储结构

### 3.2.1 二叉树的定义及性质

+ 二叉树T：一个有穷的结点集合
  + 这个集合可以为空
  + 若不为空，则它是由根节点和称为其左子树$T_L$和右子树$T_R$的两个不相交的二叉树组成
    + 二叉树具有五种基本形态（空，无子结点，拥有左子树，拥有右子树，拥有左右子树）
  + 特殊二叉树
    + 斜二叉树(Skewed Binary Tree)
    + 完美二叉树(Perfect Binary Tree) 满二叉树(Full Binary Tree)
    + 完全二叉树(Complete Binary Tree)：与满二叉树序号一致
  + 重要性质
    + 一个二叉树第$i$层的最大节点数为$2^{i-1},i\ge1$
    + 深度为$k$的二叉树有最大结点总数为$2^k-1,k\ge1$
    + 对任何非空二叉树T，若$n_0$表示叶结点的个数，$n_2$是度为2的非叶结点个数，那么两者满足关系$n_0=n_2+1$
      + $n_0+n_1+n_2-1=0\times n_0+1\times n_1+2\times n_2$
  + 二叉树的抽象数据类型定义
    + 名称：二叉树
    + 数据对象集：一个有穷的结点集合
      + 若不为空，则由根结点和其左、右二叉子树组成
    + 操作集
    > 判断是否为空
    > 遍历
    > 创建一个二叉树

遍历方法：

 ``` c
void PreOrderTraversal(BinTree BT) //先序遍历（根，左子树，右子树）
void InOrderTraversal(BinTree BT) //中序遍历（左子树，根，右子树）
void PostOrderTraversal(BinTree BT) //后序遍历（左子树，右子树，根）
void LevelOrderTraversal(BinTree BT) //层序遍历（从上到下，从左到右）
 ```

层序遍历需要使用队列实现

### 3.2.2 二叉树的存储结构

+ 顺序存储结构
  + 完全二叉树适合使用数组实现
  + n个结点的完全二叉树的结点父子关系
    + 非根结点（序号i>1）的父结点序号为$\left \lfloor i/2 \right \rfloor$
    + 结点（序号为i）左孩子结点序号为2i，（若2i<=n，否则没有左孩子）
    + 结点（序号为i）左孩子结点序号为2i+1，（若2i+1<=n，否则没有左孩子）
  + 一般的二叉树也可以采用这样的结构，但会造成空间浪费
+ 链式存储结构
  + 链表存储，包含两个指针域

## 3.3 二叉树的遍历

### 3.3.1 先序中序后序遍历

+ 三种递归遍历经过节点的路径相同。
+ 先序遍历
  + 遍历过程
    + 访问根节点
    + 先序遍历其左子树
    + 先序遍历其右子树
  + 第一次经过节点时访问
+ 中序遍历
  + 遍历过程
    + 中序遍历其左子树
    + 访问根节点
    + 中序遍历其右子树
  + 第二次经过节点时访问
+ 后序遍历
  + 遍历过程
    + 后序遍历其左子树
    + 后序遍历其右子树
    + 访问根节点
  + 第三次经过结点时访问

### 3.3.2 中序非递归遍历

+ 中序遍历非递归遍历算法
  + 非递归算法实现的基本思路：使用堆栈
  + 首先参考之前的执行序列
  + 中序遍历非递归遍历算法
    + 遇到结点压栈，并去遍历它的左子树
    + 左子树遍历完成后，弹出结点并访问它
    + 然后中序遍历这个结点的右子树
+ 先序遍历push时直接访问
+ 后序遍历 左右子树为空或完成遍历后弹出并打印

### 3.3.3 层序遍历

二叉树遍历的核心问题：二维结构的线性化

+ 需要找到左右子结点（从父结点访问）
+ 访问左子结点后，右子结点怎么办
  + 需要一个存储结构保存暂时不访问的结点
  + 存储结构：堆栈，队列

+ 层序遍历：使用队列实现
  + 根结点入队
  + 从队列中取出一个元素
  + 访问结点
  + 左右孩子结点非空，则将其左右子结点顺序入队

### 3.3.4 遍历应用例子

+ 输出二叉树中的叶结点
+ 输出二叉树的高度（深度）
  + 左右子树最高树高加1
+ 二元运算表达式树及其遍历
  + 三种遍历得到前缀，中缀（不准确）与后缀表达式
  + 解决方式：加括号
+ 由两种遍历系列确定二叉树
  + 必须含有中序遍历结果

## 例：树的同构 03-树1
