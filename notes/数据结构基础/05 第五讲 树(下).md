# 第五讲 树(下)

## 5.1 堆

堆(Heap)

### 5.1.1 什么是堆

+ 优先队列(Priority Queue)：特殊的“队列”，取出元素的顺序是依照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序。
+ 采用顺序结构实现
  + 存在一系列问题
+ 采用二叉树存储结构
  + 更应该关注删除
  + 使用完全二叉树实现

最大堆：对于树中的任何一棵子树，根结点总是树的最大结点
最小堆：对于树中的任何一棵子树，根结点总是树的最小结点

+ 堆的抽象数据类型描述
  + 最大堆(MaxHeap)
  + 数据对象集
    + 完全二叉树，每个结点的元素值不小于其子结点的元素值
  + 操作集
    + 创建
    + 判断是否已满
    + 插入元素
    + 判断是否为空
    + 返回最大元素（高优先级）

### 5.1.2 堆的插入

和父结点比较，如果大于父结点，则交换位置，并继续向上比较

### 5.1.3 堆的删除

使用较大的子树替换根的位置，并依次继续

### 5.1.4 堆的建立

建立最大堆

+ 方法1
  + 通过插入操作 代价为NlogN
+ 方法2 线性时间复杂度下调整
  + 将N个元素按输入顺序存入，先满足完全二叉树的特性
  + 调整各结点位置，以满足最大堆的有序特性

## 5.2 哈夫曼树与哈夫曼编码

根据频率确定编码位数

使用不等长编码节省存储空间

### 5.2.1 什么是哈夫曼树

不同方法构造效率较优的搜索树

哈夫曼树的定义

+ 带权路径长度(WPL)：设二叉树有$n$个叶子结点，每个叶子结点带有权值$w_k$，从根结点到叶结点的长度为$l_k$，则每个叶结点的带权路径长度之和就是：$WPL=\sum_{k=1}^{n}{w_kl_k}$
+ 最优二叉树或哈夫曼树:WPL最小的二叉树

### 5.2.2 哈夫曼树的构造

+ 每次把权值最小的两棵二叉树合并
  + 如何选取两个最小的（利用堆，排序的方法效率较堆低）
+ 哈夫曼树的特点
  + 没有度为1的结点
  + n个叶节点的哈夫曼树共有2n-1个结点
  + 哈夫曼树的任意非叶结点的左右子树交换后仍是哈夫曼树
  + 对同一组权值，可能产生不同构的哈夫曼树，但它们的WPL相同

### 5.2.3 哈夫曼编码

+ 给定一组字符串，如何对其进行编码

怎样进行不等长编码

+ 避免二义性
+ 前缀码(prefix code)：任何字符的编码都不是另一字符编码的前缀
+ 所有字符都在叶节点上，即可避免出现二义性

## 5.3 集合及运算

### 5.3.1 集合的表示及查找

+ 集合的表示
  + 集合运算：交，并，补，差，判定一个元素是否属于某一集合
  + 并查集：集合并、查某元素属于什么集合
  + 并查集问题中集合存储如何实现
    + 可以使用树结构表示集合，树的每个结点代表一个集合元素
    + 双亲表示法：孩子指向双亲
    + 可采用数组存储（结构数组）

### 5.3.2 集合的并运算

+ 集合运算
  + 查找某个元素所在的集合(Find操作的实现)
  + 集合的并运算
    + 找到根节点，将其中一个根节点的父结点设置成另外一个根节点下标
    + 尽量将较小集合置入较大集合
