# 第九讲 排序(上)

## 9.1 简单排序

### 9.1.1 概述

排序算法的效率在大数据量时非常重要

这里讨论的是整数排序

+ 要求正整数
+ 只讨论基于比较的排序
+ 只讨论内部排序
+ 稳定性：任意两个相等的数据，排序前后的相对位置不发生改变
+ 没有一种排序是任何情况下都表现最好的

### 9.1.2 冒泡排序

交换两个相邻的数据
最坏时间复杂度为O(n^2)

``` c
void Bubble_Sort(ElementType A[], int N)
{
    // 当没有发生元素交换时，已经完成排序
}
```

+ 最好情况： 顺序 T=O(N)
+ 最坏情况： 逆序 T=O(N^2)

可以在链表中使用
严格大于时才作交换，即排序算法稳定

### 9.1.3 插入排序

+ 最好情况： 顺序 T=O(N)
+ 最坏情况： 逆序 T=O(N^2)

严格大于错位，依然稳定

与冒泡排序有相似性质（公共时间复杂度下限）

### 9.1.4 时间复杂度下限

+ 对于下标 i < j, 如果A[i] > A[j]，则称(i,j)是一对逆序对(inversion)
+ 上一节末尾的例子中具有9个逆序对
+ 交换两个相邻元素正好消去1个逆序对
+ 插入排序： T(N,I)=O(N+I)
  + 如果序列基本有序，则插入排序简单且高效

定理

+ 任意N个不同元素组成的序列平均有N(N-1)/4个逆序对
+ 任何仅以交换相邻两元素来排序的算法，其时间复杂度为$\Omega(N^2)$
+ 以上两个定理，一位置提高算法效率
  + 每次消去不止一个逆序对
  + 每次交换相隔较远的两个元素

## 9.2 希尔排序

利用了插入排序的简单，并且克服插入排序每次只交换两个元素的缺点

+ 逐渐减小间隔

+ 定义增量序列
+ 对每个D_k进行“Dk-间隔”排序
+ 性质：
  + D_k间隔有序的序列，在执行“D_k-1-间隔”排序后，仍然是“D_k-间隔”有序的

+ 原始希尔排序D_M=Floor(N/2), D_k=Floor((D_k+1)/2)
+ 最坏情况 T=\Theta(N^2)

+ 坏的例子
  + 增量元素不互质，则小增量可能根本不起作用
+ HIbbard 增量序列
  + D_k = 2^k-1 相邻元素互质
  + 最坏情况： T=\Theta(N^{3/2})
  + 猜想： T_{avg}=O(N^{5/4})
+ Sedgewick增量序列
  + {1,t,9,41,109,...}
    + 9x4^i-9x2^i+1 或 4^i-3x2^i+1
  + 猜想 T_{avg}=O(N^{7/6}), T_{worst}=O(N^{4/3})

## 9.3 堆排序

### 9.3.1 选择排序

算法思路

+ 从A[i]到A[N-1]中寻找最小元，并将其位置赋给MinPosition
+ 将未排序部分的最小元换到有序部分的最后位置
+ 无论如何 T=\Theta(N^2)

### 9.3.2 堆排序

对选择排序的一种改进

+ 算法（直接建堆）
  + T(N) = O(NlogN)
  + 缺点：需要额外O(N)空间，并且复制元素需要时间
+ 算法 （最大堆）
  + 将根结点与最后一个结点相交换
  + 导致孩子结点下标发生变化
  + 定理：堆排序处理N个不同元素的随机排列的平均比较次数是 2NlogN-O(NloglogN)
  + 虽然堆排序给出了最佳平均时间复杂度，但实际效果不如用Sedgewick增量序列的希尔排序

## 9.4 归并排序

核心：有序子序列的归并

### 9.4.1 有序子序列的归并

归并的时间复杂度
T(N) = O(N)

### 9.4.2 递归算法

+ 分而治之
  + 递归算法
    + 时间复杂度为 T(N)=O(NlogN)
  + 算法稳定
  + 还需要一个统一的函数接口
+ 如果只在Merge中声明临时数组，造成多次内存分配的开销

### 9.4.3 非递归算法

思路：每次对相邻的子序列进行归并

额外空间复杂度是O(N)

+ 依然稳定
+ 并且需要额外空间（基本不用于内排序，而在外排序中广泛使用）
