# 第十讲 排序(下)

## 10.1 快速排序

### 10.1.1 算法概述

+ 采用分而治之的思想
  + 首先选择主元
  + 根据主元分为两个子集
  + 递归两侧
+ 最好情况：主元正好位于数组的中间

### 10.1.2 选主元

+ 令pivot = A[0]
  + 这种方法并不优秀
  + T(N) = O(N) + T(N-1)
    + 这导致了T(N)=O(N^2)
+ 随机取pivot? rand()函数开销也较大
+ 取头、中、尾的中位数

### 10.1.3 子集划分

+ 记录下标
+ 与主元比较
  + 发现错误后交换两元素
  + 当i > j 后停止，将主元置于i处
+ 有元素正好等于主元
  + 停下来交换：每次递归都得到等长序列
  + 忽略，继续移动指针（避免无用交换），但是主元位于极端位置

+ 小规模数据的处理
  + 快速排序的问题
    + 使用了递归
    + 对于小规模数据，速度可能不如插入排序
  + 解决方案
    + 当递归的数据规模充分小，则停止递归，直接调用简单排序
    + 在程序中定义一个Cutoff的阈值 （在课后实现，比较不同Cutoff对效率的影响）

### 10.1.4 算法实现

```c
// 这个程序还需要加壳以满足要求
void Quicksort(ElementType A[], int Left, int Right)
{
    if(Cutoff <= Right - Left)
    {
        Pivot = Median3(A, Left, Right);
        i = Left; j = Right - 1;
        for(; ;)
        {
            while(A[++i] < Pivot){}
            while(A[--j] > Pivot){}
            if(i < j)
                Swap(&A[i], &A[j]) ;
            else
                break;
        }
        Swap( &A[i], &A[Right - 1]);
        Quicksort(A, Left, i - 1);
        Quicksort(A, i + 1, Right);
    }
    else
    {
        Insertion_Sort (A + Left, Right - Left + 1);
    }
}
```

## 10.2 表排序

不移动原始数据，仅仅移动指针

### 10.2.1 算法概述

+ 间接排序
  + 定义一个指针数组作为"表"(table)
  + 不需要排序元素，而是直接对数组进行排序

### 10.2.2 物理排序

由指针信息调整得到物理结构

+ N个数字的排列由若干个独立的环组成
  + 应该如何判断一个环的结束
    + table[i] == i时，环已经结束
  + 复杂度分析
    + 最好情况： 按照顺序排列
    + 最坏情况： 有N/2个环，每个环包含两个元素
      + 需要3N/2次元素移动
      + T = O(mN), m为每个A元素的复制时间，这里的m不可忽略

## 10.3 基数排序

基于比较的排序具有理论性能上限

### 10.3.1 桶排序

+ 假设有N个学生，它们的成绩是0到100之间的整数，如何在线性时间内将学生按成绩排序

``` c
void Vucket_Sort(ElementType A[], int N)
{
    // 初始化count
    while(/* 读入学生成绩grade */)
        /* 将学生插入count[grade]链表 */;
    for(i = 0; i < M, i++){
        if (count[i])
            /* 输出整个count[i]链表 */ ;
    }
}

```

// M >> N 如何解决？

### 10.3.2 基数排序

基数排序，次位优先排序(Least Significant Digit)
桶排序，取决于基数与桶的个数

### 10.3.3 多关键字的排序

主关键字与次关键字排序
主位优先(Most Significant Digit)排序，为花色建立四个桶

LSD MSD 的效率问题

## 10.4 排序算法的比较
