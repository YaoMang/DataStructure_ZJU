# 第十一讲 散列查找

## 11.1 散列表

+ 背景：编译处理时，设计变量及属性（如变量类型）的管理
  + 插入：新变量定义
  + 查找：变量的引用

### 11.1.1 引子：散列的基本思路

属于动态查找，问题：两个变量名（字符串）比较效率不高

+ 已知查找方法
  + 顺序查找 O(N)
  + 二分查找（静态查找）O(logN)
  + 树查找 （会涉及到字符串比较）
    + 二叉搜索树 O(h)
    + 平衡二叉树 O(logN)

+ 查找的本质：已知对象，查找位置
  + 有序安排对象
  + 直接”算出“对象位置

+ 散列查找法的两项基本工作
  + 计算位置： 构造散列函数确定关键词的位置
  + 解决冲突： 应用某种策略解决多个关键词位置相同的问题
+ 时间复杂度几乎都是常量O(1)，即查找时间与问题规模无关

### 11.1.2 什么是散列表

散列表（哈希表）

核心函数：  
Find()  
Insert()  
Delete()  

+ 散列(Hashing)的基本思想
  1. 以关键字key为变量，通过一个确定的函数h(散列函数)，计算出对应的函数值h(key)，作为数据对象的存储地址
  2. 可能不同关键字得到的h(key)相同，这时称为冲突

## 11.2 散列函数的构造

+ 好的散列函数
  + 计算简单，以便提高转换速度
  + 关键词对应的地址空间分布均匀，以尽量减少冲突

### 11.2.1 数字关键词的散列函数构造

+ 数字关键词的散列函数构造
  1. 直接定址法
    取关键词的某个线性函数值为散列地址，即 h(key) = a x key + b (a,b为常数)
  2. 除留余数法
  散列函数为： h(key) = key mod p
  例： h(key)=key%17
  p = Tablesize = 17
  为了映射均匀，p一般取素数
  3. 数字分析法
  分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址
  4. 折叠法
  把关键词分割成位数相同的几个部分，然后叠加
  5. 平方取中法
  希望散列值能被尽量多的位数影响

### 11.2.2 字符串关键词的散列函数构造

+ 字符串关键词的散列函数构造
  1. 一个简单的散列函数——ASCII码加和法
  对字符型关键字key定义散列函数：
  h(key) = (sum key[i])mod TableSize
  这种方法重复严重
  2. 简单的改进——前三个字符移位法
  h(key)=(key[0]x27^2 + key[1]x27 + key[2]) mod TableSize
  依然有重复，并且存在空间浪费
  3. 好的散列函数——移位法
  涉及关键词所有n个字符，并且分布地很好
  h(key)=(sum[n-i-1]x32^i) mod TableSize

+ 如何快速计算
  + 看作级数求和

## 11.3 冲突处理方法

+ 常用处理冲突的思路
  + 换个位置：开放定址法
  + 同一位置冲突对象组织在一起：链地址法

### 11.3.1 开放定址法

+ 开放定址法(OpenAddressing)
  + 一旦产生了冲突（该地址已有其他元素），就按照某种规则去寻找另一空地址
  + 若发生了第i次冲突，试探的下一个地址将增加d_i，基本公式是：
  $ h_i(key) = (h(key) + d_i) mod TableSize (1 \le i < TableSize) $
  + $d_i$决定了不同的解决冲突方案：线性探测、平方探测、双散列

### 11.3.2 线性探测

+ 线性探测法：以增量序列1,2,...，(TableSize - 1)循环试探下一个存储地址
+ 容易发生聚集

散列表查找性能分析

+ 成功平均查找长度 (ASLs)
+ 不成功平均查找长度 (ASLu)

不成功查找长度需要分类计算

### 11.3.3 线性探测的例子-字符串的例子

字符串的例子

### 11.3.4 平方探测法

二次探测

+ 存在表中存在空位，但无法置入的问题
  + 有定理显示，如果散列表长度TableSize是某个4k+3（k是正整数）形式的素数时，平方探测法就可以探查到整个散列表空间
+ 也有聚集问题，但没有线性严重

### 11.3.5 平方探测法的实现

实现例子

```c
typedef struct HashTbl *HashTable;
struct HashTbl{
    int TableSize;
    Cell *TheCells;
}H;

HashTable InitializeTable(int tableSize)
{
    HashTable H;
    int i;
    if( TableSize < MinTableSize){
        Error("散列表太小");
        return NULL;
    }

    /* 分配散列表 */
    H = (HashTable)malloc(sizeof(struct HashTbl));
    if( H == NULL)
        FatalError("空间溢出");
    H->TableSize = NextPrime( TableSize);
    /* 分配散列表Cells */
    H->TheCells=(Cell*)malloc(sizeof(Cell)*H->TableSize);
    if(H->TheCells == NULL)
        FatalError("空间溢出");
    for(i = 0l i < H->TableSize; ++i)
        H->TheCells[i],Info = Empty;
    return H
}

Position Find( ElementType Key, HashTable H);


```

+ 双散列探测法(Double Hashing)
  + 双散列探测法：$d_i$为$i*h_2(key)$, h_2(key)是另一个散列函数
    + 探测序列为 h_2(key), 2h_2(key), 3h_2(key),...
  + 对任意key,h_2(key) \ne 0
  + 探测序列还应该保证所有的散列存储单元都应该能够被探测到。选择以下形式有良好的效果
    + h_2(key) = p - (key mod p)
    + 其中p < TableSize, p , TableSize 都是素数

+ 再散列(Rehashing)
  + 当散列表酸雨太多（装填因子太大）时，查找效率会下降
    + 散列表扩大时，原有元素需要重新计算放置到新表中
    + 实用最大装填因子一般取 0.5 <= \alpha <= 0.85
  + 当装填因子过大时，解决的方法是加倍扩大散列表，这个过程叫做“再散列(Rehashing)”

### 11.3.6 分离链接法

+ 分离链接法(Separate Chaining)
  + 将相应位置上冲突的所有关键字存储在同一个单链表中

## 11.4 散列表的性能分析

+ 平均查找长度（ASL）用来度量散列表查找效率：成功，不成功
+ 关键词的比较次数，取决于产生冲突的多少
  + 影响产生冲突的多少有以下三个因素
    + 散列函数是否均匀
    + 处理冲突的方法
    + 散列表的装填因子$ \alpha $

1. 线性探测法的查找性能
2. 平方探测法和双散列探测法的查找性能
3. 分离链接法的查找性能
  分离链接法的装填因子可能大于1

+ 选择合适的h(key),散列法的查找效率期望是上述O(1),它几乎与关键字的空间的大小与n无关，也适合于关键字直接比较计算量大小的问日
+ 它是以较小的$\alpha$为前提，因此，散列方法是一个以空间换时间的查找方法
+ 散列方法的存储对关键字是随机的卖不便于顺序查找关键字，也不适合于范围查找，或最大值最小值查找

两种方法的比较

+ 开放地址法
  + 散列表是一个数组，存储效率高且支持随机查找
  + 散列表有“聚集”现象
+ 分离链法
  + 散列表是顺序存储和链式存储的结合，链表部分的存储效率和查找效率都比较低
  + 关键字不需要“懒惰删除”法，从而没有存储“垃圾”
  + 太小的$\alpha$可能导致空间浪费，大的$\alpha$又将付出更多的时间代价。不均匀的链表长度导致时间效率的严重下降

## 11.5 应用实例：词频统计

+ 词法分析
  + 分割单词
+ 查找类型为动态查找
